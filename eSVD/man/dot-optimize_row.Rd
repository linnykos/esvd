% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix_factorization.R
\name{.optimize_row}
\alias{.optimize_row}
\title{Optimize a vector}
\usage{
.optimize_row(
  dat_vec,
  current_vec,
  other_mat,
  n,
  p,
  max_iter = 100,
  max_val = NA,
  ...
)
}
\arguments{
\item{dat_vec}{a vector}

\item{current_vec}{a vector}

\item{other_mat}{a matrix with the number of rows equal to \code{length(dat_vec)} and the
number of columns equal to \code{length(current_vec)}}

\item{n}{the number of rows of \code{dat} when called on in \code{eSVD:::.optimize_mat}}

\item{p}{the number of columns of \code{dat} when called on in \code{eSVD:::.optimize_mat}}

\item{max_iter}{maximum number of iterations for the algorithm}

\item{max_val}{maximum magnitude of the inner product}

\item{...}{extra arguments, such as nuisance parameters for \code{"neg_binom"}
or \code{"curved gaussian"} for \code{family}}
}
\value{
a vector of length \code{current_vec}
}
\description{
Given a data vector \code{dat_vec} where \code{attr(dat, "family")} is \code{family} (i.e., tells us which negative
log-likelihood function we want to optimize over), optimize the values in
\code{current_vec} holding the values in \code{other_mat} fixed.
This function does a gradient descent, so the values in \code{current_vec}
are important since they determine the "initial values" of the optimization
procedure as well as ensure that these initial values are feasible for the optimization
problem.
}
\details{
This function uses Frank-Wolfe, mainly using \code{eSVD:::.frank_wolfe}.
This function is called by \code{eSVD:::.optimize_mat}.
}
